# Malware Detection Using Feedforward Neural Network

## Dataset Description

This dataset is sourced from Kaggle.com and is designed for malware detection, containing various features that capture important information about the behavior and characteristics of software applications. It allows the classification of these applications as either "malware" or "benign." The dataset includes the following 35 features:

### Feature Descriptions

1. **hash**: APK/SHA256 file name.
   - Identifier for data records.

2. **millisecond**: Represents time.
   - Temporal information, useful for analyzing time-based patterns.

3. **classification**: Malware/benign.
   - Target variable indicating whether a record is classified as "malware" or "benign."

4. **state**: Flag of unrunnable/runnable/stopped tasks.
   - Reflects the status of tasks, providing insights into task behavior and resource usage.

5. **usage_counter**: Task structure usage counter.
   - Tracks the usage of task structures, indicative of resource consumption and task activities.

6. **prio**: Keeps the dynamic priority of a process.
   - Maintains the dynamic priority of a process, affecting task scheduling and resource allocation.

7. **static_prio**: Static priority of a process.
   - Represents the static priority of processes, influencing task execution order.

8. **normal_prio**: Priority without taking RT-inheritance into account.
   - Reflects priority without considering real-time (RT) inheritance, impacting task scheduling.

9. **policy**: Planning policy of the process.
   - Determines the planning policy for process management, influencing task behavior.

10. **vm_pgoff**: Offset of the area in the file, in pages.
    - Indicates the file area's offset, possibly related to file operations and memory management.

11. **vm_truncate_count**: Used to mark a vma as now dealt with.
    - Tracks the handling of virtual memory areas (VMAs), affecting memory management.

12. **task_size**: Size of the current task.
    - Reflects the size of the task, which can be influenced by task-related activities.

13. **cached_hole_size**: Size of free address space hole.
    - Indicates the size of free address space holes, relevant to memory usage patterns.

14. **free_area_cache**: First address space hole.
    - Represents the initial address space hole, influencing memory allocation.

15. **mm_users**: Address space users.
    - Reflects address space users, impacting memory management and usage.

16. **map_count**: Number of memory areas.
    - Tracks the count of memory areas, affecting memory allocation and resource usage.

17. **hiwater_rss**: Peak of resident set size.
    - Represents the peak resident set size (RSS), influencing memory-related patterns and performance.

18. **total_vm**: Total number of pages.
    - Indicates the total number of pages, relevant to memory management.

19. **shared_vm**: Number of shared pages.
    - Reflects the count of shared memory pages, impacting memory sharing patterns.

20. **exec_vm**: Number of executable pages.
    - Indicates the count of executable pages, relevant to code execution.

21. **reserved_vm**: Number of reserved pages.
    - Represents the number of reserved pages, affecting resource allocation.

22. **nr_ptes**: Number of page table entries.
    - Tracks the count of page table entries, important for memory management.

23. **end_data**: End address of code component.
    - Reflects the end address of the code component, influenced by code execution.

24. **last_interval**: Last interval time before thrashing.
    - Provides insights into system behavior before and during thrashing incidents.

25. **nvcsw**: Number of volunteer context switches.
    - Reflects the count of voluntary context switches, affecting context switch patterns.

26. **nivcsw**: Number of involuntary context switches.
    - Indicates the count of involuntary context switches, influenced by system behavior.

27. **min_flt**: Minor page faults.
    - Reflects minor page faults, relevant to memory access efficiency and system performance.

28. **maj_flt**: Major page faults.
    - Indicates major page faults that can affect system performance and responsiveness.

29. **fs_excl_counter**: Holds file system exclusive resources.
    - Tracks file system exclusive resources, relevant to file system access and resource management.

30. **lock**: The read-write synchronization lock used for file system access.
    - Reflects the synchronization lock for file system access, affecting access efficiency and synchronization.

31. **utime**: User time.
    - Reflects the user time used in user mode, influencing task execution and resource consumption.

32. **stime**: System time.
    - Indicates system time used in system mode, relevant to system resource consumption.

33. **gtime**: Guest time.
    - Reflects guest time, relevant in virtualized environments and guest resource usage.

34. **cgtime**: Cumulative group time. Cumulative resource counter.
    - Serves as a cumulative resource counter, tracking the cumulative impact of resource consumption.

35. **signal_nvcsw**: Used as a cumulative resource counter.
    - Represents a cumulative resource counter used for signal handling and context switch-related resource usage.

### Dataset Summary

- Total Records: 100,000
- Malware Records: 50,000
- Benign Records: 50,000

## Feedforward Neural Network (FNN) Model

To classify the applications as "malware" or "benign" based on the dataset features, we use a Feedforward Neural Network (FNN) model. The model architecture includes the following components:

- Input Layer: The input layer accepts the 35 features from the dataset.
- Hidden Layers: The model includes one or more hidden layers with ReLU activation functions to capture complex patterns in the data.
- Dropout Layer: To prevent overfitting, a dropout layer is included.
- Output Layer: The output layer uses the softmax activation function for binary classification, producing the "malware" or "benign" classification.

Feel free to explore the dataset and use the FNN model for your malware detection tasks. You can customize the model architecture or use additional machine learning techniques to achieve the best classification results for your specific use case.

For more details on using the dataset and the FNN model, please refer to the documentation or contact the dataset owner.

